namespace USocket.Public{    using System;    using System.Collections;    using System.IO;    using System.Runtime.InteropServices;    public class TypeConvert    {        public TypeConvert()        {        }        public static byte[] getBytes(float s, bool asc)        {            int buf = (int)(s * 100);            return getBytes(buf, asc);        }        public static float getFloat(byte[] buf, bool asc)        {            int i = getInt(buf, asc);            float s = (float)i;            return s / 100;        }        public static byte[] getBytes(short s, bool asc)        {            byte[] buf = new byte[2];            if (asc)            {                for (int i = buf.Length - 1; i >= 0; i--)                {                    buf[i] = (byte)(s & 0x00ff);                    s >>= 8;                }            }            else            {                for (int i = 0; i < buf.Length; i++)                {                    buf[i] = (byte)(s & 0x00ff);                    s >>= 8;                }            }            return buf;        }        public static byte[] getBytes(int s, bool asc)        {            byte[] buf = new byte[4];            if (asc)                for (int i = buf.Length - 1; i >= 0; i--)                {                    buf[i] = (byte)(s & 0x000000ff);                    s >>= 8;                }            else                for (int i = 0; i < buf.Length; i++)                {                    buf[i] = (byte)(s & 0x000000ff);                    s >>= 8;                }            return buf;        }        public static byte[] getBytes(long s, bool asc)        {            byte[] buf = new byte[8];            if (asc)                for (int i = buf.Length - 1; i >= 0; i--)                {                    buf[i] = (byte)(s & 0x00000000000000ff);                    s >>= 8;                }            else                for (int i = 0; i < buf.Length; i++)                {                    buf[i] = (byte)(s & 0x00000000000000ff);                    s >>= 8;                }            return buf;        }        public static short getShort(byte[] buf, bool asc)        {            if (buf == null)            {                //throw new IllegalArgumentException("byte array is null!");            }            if (buf.Length > 2)            {                //throw new IllegalArgumentException("byte array size > 2 !");            }            short r = 0;            if (!asc)                for (int i = buf.Length - 1; i >= 0; i--)                {                    r <<= 8;                    r |= (short)(buf[i] & 0x00ff);                }            else                for (int i = 0; i < buf.Length; i++)                {                    r <<= 8;                    r |= (short)(buf[i] & 0x00ff);                }            return r;        }        public static int getInt(byte[] buf, bool asc)        {            if (buf == null)            {                // throw new IllegalArgumentException("byte array is null!");            }            if (buf.Length > 4)            {                //throw new IllegalArgumentException("byte array size > 4 !");            }            int r = 0;            if (!asc)                for (int i = buf.Length - 1; i >= 0; i--)                {                    r <<= 8;                    r |= (buf[i] & 0x000000ff);                }            else                for (int i = 0; i < buf.Length; i++)                {                    r <<= 8;                    r |= (buf[i] & 0x000000ff);                }            return r;        }        public static long getLong(byte[] buf, bool asc)        {            if (buf == null)            {                //throw new IllegalArgumentException("byte array is null!");            }            if (buf.Length > 8)            {                //throw new IllegalArgumentException("byte array size > 8 !");            }            long r = 0;            if (!asc)                for (int i = buf.Length - 1; i >= 0; i--)                {                    r <<= 8;                    r |= ((long)buf[i] & 0x00000000000000ff);                }            else                for (int i = 0; i < buf.Length; i++)                {                    r <<= 8;                    r |= ((long)buf[i] & 0x00000000000000ff);                }            return r;        }    }    /// <summary>    /// 字节 整形 转换类 网络格式转换为内存格式    /// </summary>    public class Converter    {        /// <summary>        /// 转换整形数据网络次序的字节数组        /// </summary>        /// <param name="i"></param>        /// <returns></returns>        public static byte[] IntToBytes(uint i)        {            byte[] t = BitConverter.GetBytes(i);            byte b = t[0];            t[0] = t[3];            t[3] = b;            b = t[1];            t[1] = t[2];            t[2] = b;            return (t);        }        public static byte[] IntToBytes(uint source, int number)        {            byte[] t = new byte[number];            t = BitConverter.GetBytes(source);            byte temp;            for (int i = t.Length - 1; i > t.Length / 2; i--)            {                temp = t[i];                t[i] = t[t.Length - 1 - i];                t[t.Length - 1 - i] = temp;            }            return (t);        }        /// <summary>        /// 返回字节数组代表的整数数字，4个数组        /// </summary>        /// <param name="bs"></param>        /// <param name="startIndex"></param>        /// <returns></returns>        public static uint BytesToUInt(byte[] bs, int startIndex)        {            byte[] t = new byte[4];            for (int i = 0; i < 4 && i < bs.Length - startIndex; i++)            {                t[i] = bs[startIndex + i];            }            byte b = t[0];            t[0] = t[3];            t[3] = b;            b = t[1];            t[1] = t[2];            t[2] = b;            return BitConverter.ToUInt32(t, 0);        }        public static uint BytesToUInt(byte[] b, int startIndex, int number)        {            byte[] t = new Byte[number];            for (int i = 0; i < number && i < b.Length - startIndex; i++)            {                t[i] = b[startIndex + i];            }            byte temp;            for (int i = t.Length - 1; i > t.Length / 2; i--)            {                temp = t[i];                t[i] = t[t.Length - 1 - i];                t[i] = temp;            }            return (BitConverter.ToUInt32(t, 0));        }        /// <summary>        /// 没有指定起始索引        /// </summary>        /// <param name="bs"></param>        /// <returns></returns>        public static uint BytesToUInt(byte[] bs)        {            return (BytesToUInt(bs, 0));        }        /// <summary>        /// convert bytes to stream        /// </summary>        /// <param name="bytes"></param>        /// <returns></returns>        public static Stream BytesToStream(byte[] bytes)        {            Stream stream = new MemoryStream(bytes);            return stream;        }        /// <summary>        /// struct to bytes        /// </summary>        /// <param name="obj"></param>        /// <returns></returns>        public static byte[] StructToBytes(object obj)        {            int size = Marshal.SizeOf(obj);            byte[] bytes = new byte[size];            IntPtr stPtr = Marshal.AllocHGlobal(size);            Marshal.StructureToPtr(obj, stPtr, true);            Marshal.Copy(stPtr, bytes, 0, size);            Marshal.FreeHGlobal(stPtr);            return bytes;        }        /// <summary>        /// convert bytes to struct        /// </summary>        /// <param name="bytes"></param>        /// <param name="type"></param>        /// <returns></returns>        public static object BytesToStruct(byte[] bytes, Type type)        {            int size = Marshal.SizeOf(type);            if (size > bytes.Length)            {                return null;            }            IntPtr stPtr = Marshal.AllocHGlobal(size);            Marshal.Copy(bytes, 0, stPtr, size);            object obj = Marshal.PtrToStructure(stPtr, type);            Marshal.FreeHGlobal(stPtr);            return obj;        }        /// <summary>        /// get object size        /// </summary>        /// <param name="type"></param>        /// <returns></returns>        public static int GetStructSize(Type type)        {            return Marshal.SizeOf(type);        }    }}